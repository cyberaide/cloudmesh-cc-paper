\FILE{specifying-workflows.tex}

\section{Specifying Workflows}\label{specifying-workflows}

The workflow definition for cloudmesh is rather simple and intuitive.
An example is provided in Figure~\ref{fig:workflow-example}.  Here a
DAG with three nodes ar specified ($start \rightarrow a \rightarrow b \rightarrow c \rightarrow end $). The workflow executes three scripts (test-[a,b,c].sh). It contains a specific start and end noode.

\paragraph{Dependencies.}
Each dependency is specified in the {\em dependency} section while
providing sequences of names in a list such as \verb|- start,a| or in our
case where 3 more nodes are defined an additional node is appended
with \verb|,b,c,end|.

In case one wants to execute tnodes in parallel we can simply define them through a list such as

\begin{verbatim}
dependencies:
- start,a,end
- start,b,end
- start,c,end
\end{verbatim}

\paragraph{Nodes.}
Nodes can be customized in various ways within the workflow
configuration YAML file, including their job types (python, sh, jupyter,
or slurm), their virtual Python environment (by specifying
\texttt{venv}), their appearance on the graph, and other
characteristics.
This is controoled throgh a number of attributes used by the nodes in the DAG
The attributes summarized in Table~\ref{tab:nodes}.

\begin{figure}
\begin{minted}[breaklines]{yaml}
workflow:
  nodes:
    start:
       name: start
    a:
       name: a
       user: gregor
       host: localhost
       kind: local
       status: ready
       label: '{name}\nprogress={progress}'
       script: test-a.sh
    b:
       name: b
       user: gregor
       host: localhost
       kind: local
       status: ready
       label: '{name}\nprogress={progress}'
       script: test-b.sh
    c:
      name: c
      user: gregor
      host: localhost
      kind: local
      status: ready
      label: '{name}\nprogress={progress}'
      script: test-c.sh
    end:
       name: end
  dependencies:
    - sart,a,b,c,end
\end{minted}
\caption{Workflow YAML Configuration file}\label{fig:workflow-example}
\label{fig:yaml-file}
\end{figure}

\begin{table}[htb]
\caption{Node attributes}
\resizebox{.5\textwidth}{!}{
\begin{tabular}{|l|l|p{6cm}|}
\hline
{\bf Attribute} & {\bf Required} & {\bf Description} \\
\hline
\hline
name & yes & A unique name of the job, must be the same as defined in the : line \\
\hline
user & & The userame for the host \\
\hline
host & & The hostname \\
\hline
kind & & The kind of the job, which can be localhost, ssh, ... TBD  \\
\hline
status & & The status of the job in integer value between 0 and 100 \\
\hline
label & & A custom designed label \\
\hine
script & & The script name to be executed \\
\hline
\end{tabular}
}
\end{table}

\paragraph{Node label.}
One particular usefule attribute is that of a label. If no label is
used, the name of the node is used as label. However if a label is
specified one can also use attribte names, and timers to create labels
with implicit state information. This is don by introducing variables
through curly braces when defining the labels inside the label defined
in the nodes within the yaml workflow file.

For example, a label could be defined as showcased in
Figure \ref{fig:label-job}. The appropriate values will be dynamically
replaced during the execution of the workflow.
This creates a node on the graph that looks similar to the node
showcased in Figure~\ref{fig:label-node}.

Initially, the created and elapsed labels are \texttt{N/A} if the
workflow has not yet started, but they are replaced during runtime. This
can be observed by running a workflow in graph view in the web
interface. Colons must be replaced with \texttt{-\/-} and the years, months, days,
hours, minutes, and seconds can be arranged as desired, as long as the
corresponding letters remain consistent (\texttt{\%Y} \texttt{\%m}
\texttt{\%d} \texttt{\%H} \texttt{\%M} \texttt{\%S} respectively). Also,
the format of the time must come immediately following the period (see
Table \ref{fig:labels-list} for a summary of options for defining time
based attributed to be replaced in the label).

Initially, the created and elapsed labels are \mintinline{bash}|N/A| if the
workflow has not yet started, but they are replaced during runtime. This
can be observed by running a workflow in graph view in the web
interface.

In this format we must use two dashes \mintinline{bash}|--| to separate the various components. However, when rendered the dashes will be replaced with ca colon. Thus you can easily use years, months, days,
hours, minutes, and seconds can be arranged as desired, as long as the
corresponding letters remain consistent 
(\mintinline{bash}|%Y| 
\mintinline{bash}|%m|
\mintinline{bash}|%d| 
\mintinline{bash}|%H| 
\mintinline{bash}|%M| 
\mintinline{bash}|%S|
. The time format must be specified immediately following the period after a format supported time variable. If no format is specified following the period after the variable, the
datetime defaults to American format.


Nodes can be customized in various ways within the workflow
configuration YAML file, including their job types (python, sh, jupyter,
or slurm), their virtual Python environment (by specifying
\mintinline{bash}|venv|), their appearance on the graph, and other
characteristics.

If no format is specified following the period after the variable, the
datetime defaults to American format.


\begin{figure}
\smallskip
    \begin{minted}[breaklines]{yaml}
    workflow:
      nodes:
        start:
          label: 'start\nCreated={created.%Y/%m/%d, %H--%M--%S}\nWorkflow Started={t0.%Y/%m/%d, %H--%M--%S}\nNow={now.%Y/%m/%d, %H--%M--%S}\nElapsed={dt0.%M--%S}'
    \end{minted}
    \caption{Example of job label in YAML configuration file}
    \label{fig:label-job}

\centering
\includegraphics[width=0.7\columnwidth]{images/labelmaker-example.png}
\caption{An example node with labels}\label{fig:label-node}
\end{figure}

\begin{table}[htb]
\caption{List of possible labels for nodes on the graph}
\label{fig:labels-list}

{\footnotesize
\begin{tabular}{p{3.5cm}p{4cm}}
Name & Description \\
\hline
progress &  progress of job from 0-100 \\
now & current time \\
now.\verb|%Y%m%d,%H--%M--%S| & now in particular format (this can be used for other times as well) \\
created & time when workflow was created \\
t0.\verb|%Y%m%d,%H--%M--%S| &  workflow start time \\
t1.\verb|%Y%m%d,%H--%M--%S| & workflow end time \\
dt0.\verb|%Y%m%d,%H--%M--%S| & elapsed time since workflow began \\
dt1.\verb|%Y%m%d,%H--%M--%S| & total time of workflow once complete \\
tstart.\verb|%Y%m%d,%H--%M--%S| & job start time \\
tend.\verb|%Y%m%d,%H--%M--%S| & job end time \\
modified.\verb|%Y%m%d,%H--%M--%S| & job modified time \\
os. & operating system environment variable (like os.HOME) \\
cm. & cloudmesh variable that is read from \verb|cms set|} \\
\end{tabular}
}

\end{table}


\subsection{Defining graphviz shapes and
styles}\label{defining-graphviz-shapes-and-styles}

\paragraph{Shapes and Styles}

As we use graphviz for rendering we have also added the ability to change the shape and style 
for each nodes in the graph. The available \href{https://graphviz.org/doc/info/shapes.html}{shapes} and \href{https://graphviz.org/docs/attr-types/style/}){styles} are listed in the Graphviz documentation \cite{??}.

Figure \ref{fig:shape-style-yaml} is an example of a node in YAML format that uses a box shape and an empty style. The empty style defaults to \mintinline{bash}|filled|, which allows the node to change color when the job status is changed.

\begin{figure}
    \begin{minted}[breaklines]{yaml}
    workflow:
      nodes:
        start:
          label: 'start\nCreated={created.%Y/%m/%d, %H--%M--%S}\nWorkflow Started={t0.}\nElapsed={dt0.}'
          kind: local
          user: grey
          host: local
          status: ready
          exec: 'echo hello'
          name: start
          shape: box
          style: ''
    \end{minted}
    \caption{Example of YAML config file that uses shape and style}
    \label{fig:shape-style-yaml}
\end{figure}



\subsection{Reporting Progress}\label{reporting-progress}

When running scripts/jobs inside a workflow, the scripts must leverage
some format of cloudmesh.progress to run successfully. Otherwise, the
Workflow class cannot tell if the scripts are done, breaking the
progress functionality.

The examples that are provided with cloudmesh-cc are already augmented
with cloudmesh.progress. Thus, if a user is running self-made jobs and
workflows, they must adhere to the guidelines as follows.

\subsection{Shell and Slurm Scripts}\label{shell-and-slurm-scripts}

For shell and Slurm scripts \mintinline{bash}|.sh|, the script must contain:

\begin{minted}[breaklines]{bash}
echo "# cloudmesh status=running progress=1 pid=$$"
\end{minted}

at the beginning of the script, and

\begin{minted}[breaklines]{bash}
echo "# cloudmesh status=done progress=100 pid=$$"
\end{minted}

at the end of the script.

\subsection{Python Scripts and Jupyter
Notebooks}\label{python-scripts-and-jupyter-notebooks}

For Python scripts \mintinline{bash}|.py| and Jupyter notebooks \mintinline{bash}|.ipynb|,
the script must contain an import module from cloudmesh.common and calls
to the progress function.


\smallskip
\begin{minted}[breaklines]{python}
from cloudmesh.common.StopWatch import progress
from cloudmesh.common.Shell import Shell
filename = Shell.map_filename('./py_script.log').path
progress(progress=1, filename=filename)
# execute your analysis here ...
progress(progress=100, filename=filename)
\end{minted}
\smallskip

The statements do not need to be at the absolute beginning or end of the
script, but the progress must:

\begin{itemize}
\item
  be written to a filename with the same name as the script, ending in
  \mintinline{bash}|.log|
\item
  begin at progress=1
\item
  and end at progress=100
\end{itemize}
